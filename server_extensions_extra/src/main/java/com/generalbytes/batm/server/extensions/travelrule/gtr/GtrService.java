package com.generalbytes.batm.server.extensions.travelrule.gtr;

import com.generalbytes.batm.server.extensions.travelrule.IIdentityWalletEvaluationRequest;
import com.generalbytes.batm.server.extensions.travelrule.ITravelRuleTransferData;
import com.generalbytes.batm.server.extensions.travelrule.ITravelRuleTransferUpdateRequest;
import com.generalbytes.batm.server.extensions.travelrule.TravelRuleProviderException;
import com.generalbytes.batm.server.extensions.travelrule.gtr.api.GtrApi;
import com.generalbytes.batm.server.extensions.travelrule.gtr.dto.GtrNotifyTxIdResponse;
import com.generalbytes.batm.server.extensions.travelrule.gtr.dto.GtrRegisterTravelRuleRequest;
import com.generalbytes.batm.server.extensions.travelrule.gtr.dto.GtrVaspListResponse;
import com.generalbytes.batm.server.extensions.travelrule.gtr.dto.GtrVaspResponse;
import com.generalbytes.batm.server.extensions.travelrule.gtr.dto.GtrVerifyAddressRequest;
import com.generalbytes.batm.server.extensions.travelrule.gtr.dto.GtrVerifyAddressResponse;
import com.generalbytes.batm.server.extensions.travelrule.gtr.mapper.GtrProviderMapper;
import com.generalbytes.batm.server.extensions.travelrule.gtr.util.RequestIdGenerator;
import com.generalbytes.batm.server.extensions.travelrule.gtr.dto.GtrCredentials;
import com.generalbytes.batm.server.extensions.travelrule.gtr.dto.GtrNotifyTxIdRequest;
import com.generalbytes.batm.server.extensions.travelrule.gtr.dto.GtrRegisterTravelRuleResponse;
import com.generalbytes.batm.server.extensions.travelrule.gtr.dto.GtrVaspBasicInfo;
import com.generalbytes.batm.server.extensions.travelrule.gtr.dto.GtrVaspInfo;
import com.generalbytes.batm.server.extensions.travelrule.gtr.dto.GtrVerifyPiiResponse;
import com.generalbytes.batm.server.extensions.travelrule.gtr.handler.GtrTransferHandler;
import com.generalbytes.batm.server.extensions.travelrule.gtr.util.Curve25519Encryptor;
import lombok.AllArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;

import java.util.List;

/**
 * Service for Global Travel Rule (GTR) provider.
 */
@Slf4j
@AllArgsConstructor
public class GtrService {

    /**
     * Verify type for {@link GtrApi#registerTravelRuleRequest(String, GtrRegisterTravelRuleRequest)}.
     *
     * @see GtrRegisterTravelRuleRequest#getVerifyType()
     */
    private static final int VERIFY_TYPE_FOR_REGISTER_TRAVEL_RULE_REQUEST = 4;

    private final GtrApiWrapper api;
    private final RequestIdGenerator requestIdGenerator;
    private final GtrVerifyAddressService verifyAddressService;
    private final GtrVerifyPiiService verifyPiiService;
    private final GtrTransferHandler transferHandler;
    private final GtrValidator gtrValidator;
    private final Curve25519Encryptor curve25519Encryptor;

    /**
     * Get all available VASPs from Global Travel Rule (GTR).
     *
     * @param credentials {@link GtrCredentials}
     * @return List of available VASPs.
     */
    public List<GtrVaspBasicInfo> getAllVasps(GtrCredentials credentials) {
        try {
            GtrVaspListResponse response = api.listVasps(credentials);
            return response.getData();
        } catch (Exception e) {
            log.warn("Failed to fetch VASPs from GTR: {}", getExceptionMessage(e));
            throw new TravelRuleProviderException("Failed to fetch VASPs from GTR.");
        }
    }

    /**
     * Get detail about VASP from Global Travel Rule (GTR).
     *
     * @param credentials {@link GtrCredentials}
     * @param vaspCode VASP code.
     * @return Detail info about VASP.
     */
    public GtrVaspInfo getVaspDetail(GtrCredentials credentials, String vaspCode) {
        try {
            gtrValidator.validateVaspCode(vaspCode);

            GtrVaspResponse response = api.vaspDetail(credentials, vaspCode);
            return response.getData();
        } catch (Exception e) {
            log.warn("Failed to get VASP detail from GTR: {}", getExceptionMessage(e));
            throw new TravelRuleProviderException("Failed to get VASP detail from GTR.");
        }
    }

    /**
     * Registers a new Travel Rule request.
     *
     * @param credentials {@link GtrCredentials}
     * @return Object containing Request ID and Travel Rule ID generated by the GTR server.
     */
    public GtrRegisterTravelRuleResponse registerTravelRuleRequest(GtrCredentials credentials) {
        try {
            String requestId = requestIdGenerator.generateRequestId();

            GtrRegisterTravelRuleRequest request = createGtrRegisterTravelRuleRequest(credentials, requestId);
            GtrRegisterTravelRuleResponse response = api.registerTravelRuleRequest(credentials, request);

            gtrValidator.validateRegisterTravelRuleResponse(response, requestId);
            log.info("GTR request has been register. Request ID: {}, Travel Rule ID: {}", requestId, response.getTravelRuleId());

            return response;
        } catch (Exception e) {
            log.warn("Failed to register GTR request: {}", getExceptionMessage(e));
            throw new TravelRuleProviderException("Failed to register GTR request.");
        }
    }

    private GtrRegisterTravelRuleRequest createGtrRegisterTravelRuleRequest(GtrCredentials credentials, String requestId) {
        GtrRegisterTravelRuleRequest request = new GtrRegisterTravelRuleRequest();
        request.setRequestId(requestId);
        request.setSourceVaspCode(credentials.getVaspCode());
        request.setVerifyType(VERIFY_TYPE_FOR_REGISTER_TRAVEL_RULE_REQUEST);

        return request;
    }

    /**
     * Get wallet info (address verification process).
     *
     * @param credentials {@link GtrCredentials}
     * @param walletEvaluationRequest Request object containing data for obtaining wallet information from GTR.
     * @return Object containing information about wallet (result of address verification).
     */
    public GtrVerifyAddressResponse getWalletInfo(GtrCredentials credentials, IIdentityWalletEvaluationRequest walletEvaluationRequest) {
        try {
            gtrValidator.validateWalletEvaluationRequest(walletEvaluationRequest);

            String requestId = registerTravelRuleRequest(credentials).getRequestId();
            String targetVaspPublicKey = getVaspPublicKey(credentials, walletEvaluationRequest.getDidOfVaspHostingCustodialWallet());

            return verifyAddress(
                    credentials,
                    requestId,
                    targetVaspPublicKey,
                    walletEvaluationRequest.getDidOfVaspHostingCustodialWallet(),
                    walletEvaluationRequest.getCryptocurrency(),
                    walletEvaluationRequest.getCryptoAddress()
            );
        } catch (Exception e) {
            log.warn("Failed to get wallet information from GTR: {}", getExceptionMessage(e));
            throw new TravelRuleProviderException("Failed to get wallet information from GTR.");
        }
    }

    /**
     * Create a new transfer.
     *
     * @param credentials {@link GtrCredentials}
     * @param outgoingTransferData {@link ITravelRuleTransferData}
     * @return Object containing information about created transfer (result of PII verification).
     */
    public GtrVerifyPiiResponse createTransfer(GtrCredentials credentials, ITravelRuleTransferData outgoingTransferData) {
        try {
            String requestId = registerTravelRuleRequest(credentials).getRequestId();
            String targetVaspPublicKey = getVaspPublicKey(credentials, outgoingTransferData.getBeneficiaryVasp().getDid());
            verifyAddressForCreateTransfer(credentials, requestId, targetVaspPublicKey, outgoingTransferData);

            GtrVerifyPiiResponse response = verifyPiiService.verifyPii(credentials, outgoingTransferData, requestId, targetVaspPublicKey);

            transferHandler.handleVerifyPiiResponse(outgoingTransferData.getPublicId(), response);

            return response;
        } catch (Exception e) {
            log.warn("Failed to create GTR transfer: {}", getExceptionMessage(e));
            throw new TravelRuleProviderException("Failed to create GTR transfer.");
        }
    }

    private void verifyAddressForCreateTransfer(GtrCredentials credentials,
                                                String requestId,
                                                String targetVaspPublicKey,
                                                ITravelRuleTransferData outgoingTransferData
    ) {
        GtrVerifyAddressResponse verifyAddressResponse = verifyAddress(
                credentials,
                requestId,
                targetVaspPublicKey,
                outgoingTransferData.getBeneficiaryVasp().getDid(),
                outgoingTransferData.getTransactionAsset(),
                outgoingTransferData.getDestinationAddress()
        );

        if (!verifyAddressResponse.isSuccess()) {
            throw new TravelRuleProviderException("Failed to verify address with GTR when creating a transfer.");
        }
    }

    private GtrVerifyAddressResponse verifyAddress(GtrCredentials credentials,
                                                   String requestId,
                                                   String targetVaspPublicKey,
                                                   String targetVaspDid,
                                                   String cryptocurrency,
                                                   String cryptoAddress
    ) {
        try {
            GtrCryptoNetwork cryptoNetwork = GtrCryptoNetwork.getGtrCryptoNetwork(cryptocurrency);
            GtrVerifyAddressRequest request = GtrProviderMapper.toGtrVerifyAddressRequest(
                    requestId, credentials.getCurvePublicKey(), targetVaspPublicKey, targetVaspDid, cryptocurrency, cryptoAddress
            );

            return verifyAddressService.verifyAddress(credentials, request, cryptoNetwork);
        } catch (Exception e) {
            log.warn("Failed to verify address with GTR: {}", getExceptionMessage(e));
            throw new TravelRuleProviderException("Failed to verify address with GTR.");
        }
    }

    /**
     * Notifies the beneficiary VASP via GTR about the on-chain transaction hash.
     *
     * @param credentials {@link GtrCredentials}
     * @param transferUpdateRequest {@link ITravelRuleTransferUpdateRequest}
     */
    public void notifyTxId(GtrCredentials credentials, ITravelRuleTransferUpdateRequest transferUpdateRequest) {
        try {
            GtrNotifyTxIdRequest notifyTxIdRequest = GtrProviderMapper.toGtrNotifyTxIdRequest(transferUpdateRequest);
            GtrNotifyTxIdResponse response = api.notifyTxId(credentials, notifyTxIdRequest);

            if (response.isSuccess()) {
                log.info("Beneficiary VASP was successfully notified via GTR of the on-chain transaction hash: {}",
                        transferUpdateRequest.getTransactionHash());
            } else {
                log.warn("Beneficiary VASP was unable to successfully process the on-chain transaction hash notification."
                                + " Transaction hash: {}, status: {}, message: {}",
                        transferUpdateRequest.getTransactionHash(), response.getStatusCode(), response.getMessage());
            }
        } catch (Exception e) {
            log.warn("Failed to notify the beneficiary VASP via GTR about the on-chain transaction hash: {}. {}",
                    transferUpdateRequest.getTransactionHash(), getExceptionMessage(e));
            throw new TravelRuleProviderException("Failed to notify the beneficiary VASP via GTR about the on-chain transaction hash.");
        }
    }

    private String getVaspPublicKey(GtrCredentials credentials, String vaspCode) {
        GtrVaspInfo vaspInfo = getVaspDetail(credentials, vaspCode);
        return vaspInfo.getPublicKey();
    }

    private String getExceptionMessage(Exception e) {
        if (StringUtils.isNotBlank(e.getMessage())) {
            return e.getMessage();
        }

        if (e.getCause() != null && StringUtils.isNotBlank(e.getCause().getMessage())) {
            return e.getCause().getMessage();
        }

        log.trace("GTR API call failed - exception does not contain a message");
        return "Unknown error";
    }

    /**
     * Tests whether the credentials are valid. The endpoint for obtaining VASPs is used for testing.
     *
     * @param credentials {@link GtrCredentials}
     * @return {@code True} if credentials are valid, otherwise {@code false}.
     */
    public boolean testProviderCredentials(GtrCredentials credentials) {
        try {
            validateVaspCode(credentials);
            validateKeyPair(credentials);
            api.listVasps(credentials);
            return true;
        } catch (Exception e) {
            log.warn("GTR credentials test failed: {}", getExceptionMessage(e));
            return false;
        }
    }

    private void validateVaspCode(GtrCredentials credentials) {
        if (StringUtils.isBlank(credentials.getVaspCode())) {
            throw new TravelRuleProviderException("VASP code is blank");
        }
    }

    private void validateKeyPair(GtrCredentials credentials) {
        boolean keyPairValid = curve25519Encryptor.validateKeyPair(credentials.getCurvePublicKey(), credentials.getCurvePrivateKey());
        if (!keyPairValid) {
            throw new TravelRuleProviderException("Curve key pair is not valid");
        }
    }

}
