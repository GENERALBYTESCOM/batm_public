package com.generalbytes.batm.server.extensions.travelrule.sumsub;

import com.generalbytes.batm.server.extensions.travelrule.ITravelRuleProviderCredentials;
import com.generalbytes.batm.server.extensions.travelrule.ITravelRuleTransferData;
import com.generalbytes.batm.server.extensions.travelrule.ITravelRuleTransferResolvedEvent;
import com.generalbytes.batm.server.extensions.travelrule.ITravelRuleTransferUpdateRequest;
import com.generalbytes.batm.server.extensions.travelrule.TravelRuleExtensionContext;
import com.generalbytes.batm.server.extensions.travelrule.TravelRuleProviderException;
import com.generalbytes.batm.server.extensions.travelrule.TravelRuleProviderTransferStatus;
import com.generalbytes.batm.server.extensions.travelrule.sumsub.api.dto.SumsubVaspListResponse;
import com.generalbytes.batm.server.extensions.travelrule.sumsub.api.dto.submittransaction.SumsubSubmitTxWithoutApplicantRequest;
import com.generalbytes.batm.server.extensions.travelrule.sumsub.api.dto.transactioninfo.SumsubTransactionInformationResponse;
import com.generalbytes.batm.server.extensions.travelrule.sumsub.api.dto.transactionownershipresolution.SumsubTransactionOwnershipResolutionResponse;
import com.generalbytes.batm.server.extensions.travelrule.sumsub.api.dto.updatetransactionhash.SumsubUpdateTransactionHashRequest;
import com.generalbytes.batm.server.extensions.travelrule.sumsub.api.dto.updatetransactionhash.SumsubUpdateTransactionHashResponse;
import com.generalbytes.batm.server.extensions.travelrule.sumsub.api.dto.walletownershipconfirmation.SumsubConfirmWalletOwnershipRequest;
import com.generalbytes.batm.server.extensions.travelrule.sumsub.api.mapper.SumsubTravelRuleApiMapper;
import com.generalbytes.batm.server.extensions.travelrule.sumsub.common.api.SumsubApiException;
import lombok.AllArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;

import java.math.BigDecimal;

/**
 * Service for Sumsub Travel Rule provider.
 */
@Slf4j
@AllArgsConstructor
public class SumsubService {

    private final TravelRuleExtensionContext extensionContext;
    private final SumsubApiService apiService;
    private final SumsubValidator validator;

    /**
     * Get all available VASPs from Sumsub.
     *
     * @param credentials {@link ITravelRuleProviderCredentials}
     * @return A Sumsub response containing list of all available VASPs.
     */
    public SumsubVaspListResponse getAllVasps(ITravelRuleProviderCredentials credentials) {
        try {
            return apiService.getAllVasps(credentials);
        } catch (Exception e) {
            log.warn("Failed to fetch VASPs from Sumsub: {}", e.getMessage());
            throw new TravelRuleProviderException("Failed to fetch VASPs from Sumsub.");
        }
    }

    /**
     * Submit transaction for non-existing applicant.
     *
     * @param credentials          {@link ITravelRuleProviderCredentials}
     * @param outgoingTransferData {@link ITravelRuleTransferData}
     * @return An object containing response data including the Transaction ID generated by the Sumsub server.
     */
    public SumsubTransactionInformationResponse submitTransactionWithoutApplicant(ITravelRuleProviderCredentials credentials,
                                                                                  ITravelRuleTransferData outgoingTransferData
    ) {
        try {
            BigDecimal cryptoAmount = getCryptoAmount(outgoingTransferData);

            SumsubSubmitTxWithoutApplicantRequest request
                    = SumsubTravelRuleApiMapper.toSumsubSubmitTxWithoutApplicantRequest(outgoingTransferData, cryptoAmount);
            SumsubTransactionInformationResponse response = apiService.submitTransactionWithoutApplicant(credentials, request);

            validator.validateSubmitTxWithoutApplicantResponse(request, response);
            log.info("Sumsub transaction for non-existing applicant has been submitted. Txn ID: {}, Sumsub transaction ID: {}",
                    request.getTxnId(), response.getId());

            return response;
        } catch (SumsubApiException | TravelRuleProviderException e) {
            log.warn("Failed to submit transaction for non-existing applicant via Sumsub: {}", e.getMessage());
        } catch (Exception e) {
            log.warn("Failed to submit transaction for non-existing applicant via Sumsub", e);
        }
        throw new TravelRuleProviderException("Failed to submit transaction for non-existing applicant via Sumsub.");
    }

    private BigDecimal getCryptoAmount(ITravelRuleTransferData transferData) {
        return extensionContext.convertCryptoFromBaseUnit(transferData.getTransactionAmount(), transferData.getTransactionAsset());
    }

    /**
     * Update blockchain transaction hash.
     *
     * @param credentials   {@link ITravelRuleProviderCredentials}
     * @param updateRequest {@link ITravelRuleTransferUpdateRequest}
     * @return An object containing response data about updating the blockchain transaction hash.
     */
    public SumsubUpdateTransactionHashResponse updateTransactionHash(ITravelRuleProviderCredentials credentials,
                                                                     ITravelRuleTransferUpdateRequest updateRequest
    ) {
        try {
            SumsubUpdateTransactionHashRequest request = SumsubTravelRuleApiMapper.toSumsubUpdateTransactionHashRequest(updateRequest);
            SumsubUpdateTransactionHashResponse response
                    = apiService.updateTransactionHash(credentials, updateRequest.getId(), request);

            validator.validateSumsubUpdateTransactionHashResponse(updateRequest, response);
            log.info("Blockchain transaction hash has been at Sumsub. Txn ID: {}, Sumsub transaction ID: {}",
                    updateRequest.getPublicId(), response.getId());

            return response;
        } catch (SumsubApiException | TravelRuleProviderException e) {
            log.warn("Failed to update blockchain transaction hash via Sumsub: {}", e.getMessage());
        } catch (Exception e) {
            log.warn("Failed to update blockchain transaction hash via Sumsub", e);
        }
        throw new TravelRuleProviderException("Failed to update blockchain transaction hash via Sumsub.");
    }

    /**
     * Get transaction information.
     *
     * @param credentials {@link ITravelRuleProviderCredentials}
     * @param txnId       Transaction ID generated by the Sumsub server.
     * @return An object containing information about transaction.
     */
    public SumsubTransactionInformationResponse getTransactionInformation(ITravelRuleProviderCredentials credentials, String txnId) {
        try {
            SumsubTransactionInformationResponse response = apiService.getTransactionInformation(credentials, txnId);

            validator.validateSumsubTransactionInformationResponse(txnId, response);
            log.info("Transaction information was obtained from Sumsub. Txn ID: {}, Sumsub transaction ID: {}",
                    response.getData().getTxnId(), response.getId());

            return response;
        } catch (SumsubApiException | TravelRuleProviderException e) {
            log.warn("Failed to get transaction information from Sumsub: {}", e.getMessage());
        } catch (Exception e) {
            log.warn("Failed to get transaction information from Sumsub", e);
        }
        throw new TravelRuleProviderException("Failed to get transaction information from Sumsub.");
    }

    /**
     * Tests whether the credentials are valid. The endpoint for obtaining VASPs is used for testing.
     *
     * @param credentials {@link ITravelRuleProviderCredentials}
     * @return {@code True} if credentials are valid, otherwise {@code false}.
     */
    public boolean testProviderCredentials(ITravelRuleProviderCredentials credentials) {
        try {
            validateClientId(credentials);
            validateClientSecret(credentials);
            validatePrivateKey(credentials);
            apiService.getAllVasps(credentials);
            return true;
        } catch (Exception e) {
            log.warn("Sumsub credentials test failed: {}", e.getMessage());
            return false;
        }
    }

    private void validateClientId(ITravelRuleProviderCredentials credentials) {
        if (StringUtils.isBlank(credentials.getClientId())) {
            throw new TravelRuleProviderException("Client ID (token) is blank");
        }
    }

    private void validateClientSecret(ITravelRuleProviderCredentials credentials) {
        if (StringUtils.isBlank(credentials.getClientSecret())) {
            throw new TravelRuleProviderException("Client secret is blank");
        }
    }

    private void validatePrivateKey(ITravelRuleProviderCredentials credentials) {
        if (StringUtils.isBlank(credentials.getPrivateKey())) {
            throw new TravelRuleProviderException("Private key is blank (used to verify received messages on the webhook)");
        }
    }

    /**
     * Processes a transfer resolution event received from the server.
     *
     * @param credentials {@link ITravelRuleProviderCredentials}
     * @param event       {@link ITravelRuleTransferResolvedEvent}
     * @return {@code True} if the event was successfully processed, otherwise {@code false}.
     */
    public boolean handleTransferResolved(ITravelRuleProviderCredentials credentials, ITravelRuleTransferResolvedEvent event) {
        try {
            SumsubTransactionOwnershipResolutionResponse response;
            if (event.getResolvedStatus() == TravelRuleProviderTransferStatus.APPROVED) {
                response = apiService.confirmTransactionOwnership(credentials, event.getTransferExternalId());
            } else if (event.getResolvedStatus() == TravelRuleProviderTransferStatus.REJECTED) {
                response = apiService.rejectTransactionOwnership(credentials, event.getTransferExternalId());
            } else {
                log.warn("Transaction status is IN_PROGRESS, Sumsub was not informed about the transaction status."
                        + " Txn ID: {}, Sumsub transaction ID: {}", event.getTransferPublicId(), event.getTransferExternalId());
                return false;
            }

            validator.validateSumsubTransactionOwnershipResolutionResponse(event, response);
            log.info("Sumsub was informed about transaction status. Txn ID: {}, Sumsub transaction ID: {}, transaction status: {}",
                    event.getTransferPublicId(), event.getTransferExternalId(), event.getResolvedStatus());

            return confirmWalletOwnership(credentials, event);
        } catch (SumsubApiException | TravelRuleProviderException e) {
            log.warn("Failed to inform Sumsub about transaction resolution. Transaction status: {}, message: {}",
                    event.getResolvedStatus(), e.getMessage());
        } catch (Exception e) {
            log.warn("Failed to inform Sumsub about transaction resolution. Transaction status: {}", event.getResolvedStatus(), e);
        }
        return false;
    }

    /**
     * Confirms ownership of the wallet.
     *
     * @param credentials {@link ITravelRuleProviderCredentials}
     * @param event       {@link ITravelRuleTransferResolvedEvent}
     * @return {@code True} if the wallet ownership was successfully confirmed, otherwise {@code false}.
     *
     * @see <a href="https://docs.sumsub.com/docs/receive-inbound-travel-rule-data-exchange-transaction">Sumsub documentation</a>
     */
    private boolean confirmWalletOwnership(ITravelRuleProviderCredentials credentials, ITravelRuleTransferResolvedEvent event) {
        try {
            ITravelRuleTransferData transferData = getTravelRuleTransferData(event.getTransferPublicId());

            SumsubConfirmWalletOwnershipRequest request = SumsubTravelRuleApiMapper.toSumsubConfirmWalletOwnershipRequest(transferData);
            SumsubTransactionInformationResponse response
                    = apiService.confirmWalletOwnership(credentials, event.getTransferExternalId(), request);

            validator.validateSumsubConfirmWalletOwnershipResponse(event, response);
            log.info("Sumsub has been informed about the wallet ownership confirmation. Txn ID: {}, Sumsub transaction ID: {}",
                    event.getTransferPublicId(), event.getTransferExternalId());

            return true;
        } catch (SumsubApiException | TravelRuleProviderException e) {
            log.warn("Failed to confirm wallet ownership at Sumsub: {}", e.getMessage());
        } catch (Exception e) {
            log.warn("Failed to confirm wallet ownership at Sumsub", e);
        }
        return false;
    }

    private ITravelRuleTransferData getTravelRuleTransferData(String transferPublicId) {
        ITravelRuleTransferData transferData = extensionContext.findTravelRuleTransferByPublicId(transferPublicId);
        if (transferData == null) {
            throw new TravelRuleProviderException("transfer not found");
        }
        return transferData;
    }

}
